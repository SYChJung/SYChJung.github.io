<!DOCTYPE html>
<html>
	<head>
		<title>COVID-19 Coronavirus Circle Chart</title>
		<link rel="stylesheet" href="covid19.css">
	</head>
	<body>
		<h1>COVID-19 Coronavirus Circle Chart</h1>

		<section id="intro">
			<!-- Legend -->
			<ul>
				<li>Each <span class="confirmed">yellow</span> area
					represents the number of active confirmed infection cases, not yet recovered or dead.</li>
				<li>Each <span class="recoveries">green</span> area
					represents the number of recoveries.</li>
				<li>Each <span class="deaths">red</span> area
					represents the number of deaths.</li>
				<li>Each <span class="population">blue</span> "cloud" area,
					visible when you hover over, represents the population (Because the population is usually far larger than the confirmed cases, for viewing convenience, this area was colored with a gradient, with the result that only 10% of the area has color).</li>
			</ul>
			<p>
				The countries' circles are ordered by date of their first confirmed case.
			</p>
			<h2 id="date_value"></h2>
			<p>
				Use the slider below to see the chart for different dates.
			</p>
		</section>

		<svg id="chart">
			<g id="circles">
			</g>
			<g id="dummies">
			</g>
			<g id="slider">
			</g>
			<defs>
				<radialGradient id="population_gradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
					<stop offset="0%" style="stop-color: rgb(64, 224, 208); stop-opacity: 0.6" />
					<stop offset="100%" style="stop-color: rgb(255, 255, 255); stop-opacity: 0" />
				</radialGradient>
			</defs>
		</svg>

		<section id="write_up">
			<h2>Analysis</h2>
			<p>
				Just to state the obvious, <em>the number of confirmed infected cases (the <span class="confirmed">yellow</span> circles) is not the same as the actual number of infected cases</em>. For these numbers to be the same, every potentially sick person needs to seek testing, and everyone who seeks testing needs to be granted a test. This is not the case in many parts of the world, including the U.S.
			</p>
			<p>
				Moving the slider from the past to the present, we clearly see the explosion of confirmed cases (the <span class="confirmed">yellow</span> circles).
				The last week of February, starting from around Feb 21, is when there is some inkling that the virus had spread widely outside of China. From there, the explosive increase of confirmed cases can be attributed
				<ul>
					<li>partly to the exponential spread of the virus itself, and</li>
					<li>partly to belated testing that revealed there were far more undetected cases than previously thought.</li>
				</ul>
			</p>
			<p>
				A higher death rate among the confirmed infected (the <span class="deaths">red</span> circle takes up more of the <span class="confirmed">yellow</span> circle) likely means that
				<ul>
					<li>tests to confirm infection are being administered sparingly
						<br/>(the <span class="confirmed">yellow</span> circle is smaller than it would be if there were high test-seeking and test availability),</li>
					<li>by the time infections are confirmed, it is often already too late
						<br/>(the <span class="confirmed">yellow</span> circle approaches the <span class="deaths">red</span> circle), and/or</li>
					<li>the health care system is overwhelmed
						<br/>(the <span class="deaths">red</span> circle is larger than it would be if hospitals were not at full capacity).</li>
				</ul>
			</p>
			<p>
				It might be too early to say much about recovery rates. This is just to note that, as of Mar 28, it appears that
				<ul>
					<li>countries that developed test kits early, such as South Korea and Germany, have recovery numbers that far outstrip the number of deaths
						<br/>(a thick <span class="recoveries">green</span> ring around the <span class="deaths">red</span> circle),</li>
					<li>while those that experienced delays in testing have recovery numbers that are comparable to or lagging behind the number of deaths
						<br/>(a thin <span class="recoveries">green</span> ring around the <span class="deaths">red</span> circle).</li>
				</ul>
			</p>

			<h2>Design Decisions</h2>
			<p>
				I <strong>didn't plot the data on a map</strong>, because location and distance does not appear to be very significant for this virus. There is no discernible geographical trend. At best, this data on a map is good for looking up numbers for a region you can already locate on a map.
			</p>
			<p>
				(In fact, too much emphasis on geography is dangerous, especially coupled with underreporting: I think early attitudes towards the virus as an epidemic centered only in Asia might have contributed to complacency on the part of Europe and the U.S., and therefore to its spread in those areas, largely undetected and unmitigated until March.)
			</p>
			<p>
				I show data <strong>broken down by nation</strong>, because for the most part, health-care policy and disease response are implemented by nation.
			</p>
			<p>
				I wanted to show <strong>relative proportions</strong>, not just absolute numbers, <strong>but without numerically calculating proportions</strong>, as that could be misleading, especially for smaller and/or uncertain denominators.<!-- https://medium.com/nightingale/ten-considerations-before-you-create-another-chart-about-covid-19-27d3bd691be8 "determining the share of the population infected or the share of infected persons who die from the disease are incredibly challenging calculations due to uncertainty in the denominator. Proceed with extreme caution when calculating any rates, and, better yet, <em>please leave the rate calculations to the epidemiologists</em>." --> Instead, I show the proportions by plotting the absolute numbers as visually comparable areas.
			</p>
			<p>
				There were a few things to normalize for.
				<ul>
					<li>population: A blue "cloud" around each country indicates the population, so the viewer can visually note the proportions.</li>
					<li>days since the first confirmed case: While the countries are evenly spaced to help the viewer tell them apart, they are ordered by date of their first confirmed case.</li>
					<li>testing: For a more accurate picture, I would love to show another circle for testing, around the confirmed cases circle. Unfortunately, I do not have the resources of a newsroom to unearth data that is not readily available to me.</li>
				</ul>
			</p>
			<p>
				In showing these proportions, I also wanted to <strong>emphasize recovery rates as much as mortality</strong>, and also show the number of <strong>active cases</strong> that health-care systems are contending with.
			</p>
			<p>
				By adding a slider, I wanted to make it easy to see <strong>how the numbers changed over time</strong>.
			</p>
			<p>
				These are some excellent guidelines I read up on for visualizing the meaning and uncertainty of this data:
				<ul>
					<li><a target="_blank" href="https://medium.com/nightingale/ten-considerations-before-you-create-another-chart-about-covid-19-27d3bd691be8">Ten Considerations Before You Create Another Chart About COVID-19</a> by Amanda Makulec</li>
					<li><a target="_blank" href="https://blog.datawrapper.de/coronaviruscharts/">17 (or so) responsible live visualizations about the coronavirus, for you to use</a> by Lisa Charlotte Rost (Scroll down to "What we considered while creating these visualizations" and "What you should consider when using these visualizations")</li>
					<li><a target="_blank" href="https://www.esri.com/arcgis-blog/products/product/mapping/mapping-coronavirus-responsibly/">Mapping coronavirus, responsibly</a> by Kenneth Field</li>
				</ul>
			</p>

			<h2>Data Source</h2>
			<p>
				<!-- https://data.humdata.org/dataset/novel-coronavirus-2019-ncov-cases -->
				The data comes from <a target="_blank" href="https://github.com/CSSEGISandData/COVID-19">https://github.com/CSSEGISandData/COVID-19</a> that powers (or is maintained by the same people that power) the now-famous <a target="_blank" href="https://gisanddata.maps.arcgis.com/apps/opsdashboard/index.html#/bda7594740fd40299423467b48e9ecf6">global cases map</a> by the Center for Systems Science and Engineering (CSSE) at Johns Hopkins University.<span class="footnote_star">*</span> <span class="footnote_star">**</span>
			</p>
			<p>
				I would like to plot testing numbers as well, but it was not included in the above data source. Unfortunately I am not an entire newsroom. (<a target="_blank" href="https://www.businessinsider.com/coronavirus-testing-covid-19-tests-per-capita-chart-us-behind-2020-3">Business Insider</a> has a snapshot of testing rates.)
			</p>
			<p>
				Population data are from <a target="_blank" href="https://population.un.org/wpp/Download/Standard/CSV/">the United Nations' Department of Economic and Social Affairs' Population Dynamics page.<a>
				<br/>
				Population data for Kosovo and Cape Verde are from the <a target="_blank" href="https://en.wikipedia.org/wiki/Kosovo">Wikipedia page for Kosovo<a> and the <a target="_blank" href="https://en.wikipedia.org/wiki/Cape_Verde">Wikipedia page for Cape Verde.<a>
			</p>
			<p>
				<span class="footnote_star">*</span> It took me some time to make sense of the rows for the U.S. in this data set. There are rows for U.S. states and some U.S. counties (e.g. there is "California" as well as "Napa, CA"). At first glance, the rows for U.S. states appeared to be supersets of U.S. counties, but after some observation, I saw that most U.S. counties' numbers were zero. A simple sum on all "US" rows gives the total numbers for the U.S.
			</p>
			<p>
				<span class="footnote_star">**</span> There is some strangeness in the data (as of Mar 25, 2020):
				<ul>
					<li>Cape Verde recorded its first confirmed cases on Mar 21, 2020, yet its confirmed case count is 0 in Mar 23, 2020.</li>
					<li>Same with East Timor, but the data set also includes numbers under its alternate name Timor-Leste.</li>
					<li>West Bank and Gaza's confirmed cases for Mar 25, 2020 was -1.</li>
				</ul>
				I decided not to arbitrarily resolve this, instead presenting the data as is.
			</p>

			<h2>Code</h2>
			<p>
				The slider was based on <a target="_blank" href="https://github.com/arbelzinger/d3_v4_slider">https://github.com/arbelzinger/d3_v4_slider</a>
				and on <a target="_blank" href="https://github.com/MasterMaps/d3-slider">https://github.com/MasterMaps/d3-slider</a>.
			</p>
			<p>
				The tooltip was based on <a target="_blank" href="https://bl.ocks.org/d3noob/a22c42db65eb00d4e369">https://bl.ocks.org/d3noob/a22c42db65eb00d4e369 </a>
			</p>
		</section>
	</body>
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script type="text/javascript">
		d3.queue()
		.defer(d3.csv, "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv")
		.defer(d3.csv, "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv")
		.defer(d3.csv, "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_recovered_global.csv")
		.defer(d3.csv, "population_world_2020_df.csv")
		.await(
			function(error, data_confirmed, data_deaths, data_recoveries, data_population) {
				if (error) throw error;

				// ---------- ---------- clean the datasets ---------- ---------- //
				function keep_and_parse(list_of_dicts){
					list_of_dicts.forEach(
						function(dict){
							// delete unnecessary key-value pairs
							delete dict["Province/State"];
							delete dict["Lat"];
							delete dict["Long"];

							// country names: remove ", The" or "The "
							let c = dict["Country/Region"];
							let c_split = c.split(/, The$/);
							if (2 <= c_split.length){
								dict["Country/Region"] = c_split[0];
							}
							c_split = c.split(/^The /);
							if (2 <= c_split.length){
								dict["Country/Region"] = c_split[1];
							}
							// country names: special cases
							let NAME_TO_NAME = {
								"Timor-Leste" : "East Timor",
								"Reunion" : "France",
							}
							dict["Country/Region"] = NAME_TO_NAME[dict["Country/Region"]] || dict["Country/Region"];

							// parse string values to int values
							for (let key in dict){
								if (key != "Country/Region"){
									dict[key] = parseInt(dict[key]);
								}
							}

							return dict;
						}
					)

					return list_of_dicts;
				}
				function group_by_and_sum(list_of_dicts){
					let list_of_key_and_value = d3.nest()
						.key(d => d["Country/Region"])
						.rollup(
							function(values){  // `values` is a list of dicts
								let date_to_count = {};

								values.forEach(
									function(dict){
										delete dict["Country/Region"];

										for (date_key in dict){
											date_to_count[date_key] = (date_to_count[date_key] || 0) + (dict[date_key] || 0);
										}
									}
								);

								return date_to_count;
							}

							// values => d3.sum(values, g => g["3/22/20"])  // if we want the sum of "3/22/20" only
						)
						.entries(list_of_dicts);
					return list_of_key_and_value;
				}
				function reshape_to_key_to_value(list_of_key_and_value){
					let key_to_value = {};
					list_of_key_and_value.forEach(
						function(key_and_value){
							key_to_value[key_and_value["key"]] = key_and_value["value"];
						}
					);
					return key_to_value;
				}
				function skip_cruise_ship(key_to_value){
					// special cases
					delete key_to_value["Cruise Ship"];
					delete key_to_value["Diamond Princess"];

					return key_to_value;
				}

				country_to_date_to_count_confirmed  = skip_cruise_ship(reshape_to_key_to_value(group_by_and_sum(keep_and_parse(data_confirmed))));
				country_to_date_to_count_deaths     = skip_cruise_ship(reshape_to_key_to_value(group_by_and_sum(keep_and_parse(data_deaths))));
				country_to_date_to_count_recoveries = skip_cruise_ship(reshape_to_key_to_value(group_by_and_sum(keep_and_parse(data_recoveries))));

				function reshape_to_country_to_population(list_of_dicts){
					let country_to_population = {}
					// special cases
					let UN_NAME_TO_JHU_NAME = {
						"Bolivia (Plurinational State of)": "Bolivia",
						"Brunei Darussalam": "Brunei",
						"Congo" : "Congo (Brazzaville)",
						"Democratic Republic of the Congo": "Congo (Kinshasa)",
						"CÃ´te d'Ivoire": "Cote d'Ivoire",
						"Timor-Leste": 'East Timor',
						"Iran (Islamic Republic of)": 'Iran',
						"Republic of Korea": "Korea, South",
						"Republic of Moldova": "Moldova",
						"Russian Federation": "Russia",
						"Syrian Arab Republic": 'Syria',
						"China, Taiwan Province of China": 'Taiwan*',
						"United Republic of Tanzania": "Tanzania",
						"United States of America": "US",
						"Venezuela (Bolivarian Republic of)": "Venezuela",
						'Viet Nam': 'Vietnam'
					};
					list_of_dicts.forEach(
						function(dict){
							let k = UN_NAME_TO_JHU_NAME[dict["Location"]] || dict["Location"];
							country_to_population[k] = parseInt(dict["PopTotal"]);
						}
					);
					return country_to_population;
				}
				let country_to_population = reshape_to_country_to_population(data_population);

				// ---------- ---------- list of countries ordered by the date of first confirmed case ---------- ---------- //
				let country_to_date_of_1st_confirmed_case = {};
				for (let country in country_to_date_to_count_confirmed){
					let date_to_count_confirmed = country_to_date_to_count_confirmed[country];

					let date_of_1st_confirmed_case = d3.min(
						Object.keys(date_to_count_confirmed)
						.filter(date => date_to_count_confirmed[date])
						.map(date => new Date(date))
					);

					// Some of the data have only 0 values, so date_of_1st_confirmed_case is undefined
					if (date_of_1st_confirmed_case){
						country_to_date_of_1st_confirmed_case[country] = date_of_1st_confirmed_case;
					}
				}

				// early dates are not in the data
				// refernce: https://en.wikipedia.org/wiki/Timeline_of_the_2019%E2%80%9320_coronavirus_pandemic_in_November_2019_%E2%80%93_January_2020#Events,_reactions,_and_measures_in_mainland_China
				country_to_date_of_1st_confirmed_case["China"] = new Date(2019, 11 - 1, 17);
				country_to_date_of_1st_confirmed_case["Thailand"] = new Date(2020, 1 - 1, 13);
				country_to_date_of_1st_confirmed_case["Japan"] = new Date(2020, 1 - 1, 16);
				country_to_date_of_1st_confirmed_case["Korea, South"] = new Date(2020, 1 - 1, 20);
				country_to_date_of_1st_confirmed_case["Taiwan*"] = new Date(2020, 1 - 1, 21);
				country_to_date_of_1st_confirmed_case["US"] = new Date(2020, 1 - 1, 21);

				let countries_sorted_by_date_of_1st_confirmed_case =
					Object.keys(country_to_date_of_1st_confirmed_case)
					.sort(
						(countryA, countryB) => d3.ascending(  // sort by date...
							country_to_date_of_1st_confirmed_case[countryA],
							country_to_date_of_1st_confirmed_case[countryB]
						) || d3.ascending(  // ...then by country name, alphabetically
							countryA,
							countryB
						)
					);

				// ---------- ---------- first date, last date ---------- ---------- //
				// let first_date = country_to_date_of_1st_confirmed_case[
				// 	countries_sorted_by_date_of_1st_confirmed_case[0]
				// ];
				let first_date = new Date(2020, 1 - 1, 22);  // This is when the data starts
				let last_date = country_to_date_of_1st_confirmed_case[
					countries_sorted_by_date_of_1st_confirmed_case[
						countries_sorted_by_date_of_1st_confirmed_case.length-1
					]
				];

				// ---------- ---------- dimensions ---------- ---------- //
				let margin_left   = 7;
				let margin_right  = 7;
				let margin_top    = 21;
				let margin_bottom = 7;
				let outerbox_width = 1200;
				// skip padding and innerbox

				let svg_width  = margin_left + outerbox_width + margin_right;

				let slider_width = outerbox_width;
				let slider_height = 60;

				let circle_distance = 90;
				let circles_margin_left   = circle_distance / 2;
				let circles_margin_right  = circle_distance / 2;
				let circles_margin_top    = circle_distance / 2;
				let circles_margin_bottom = circle_distance / 2;

				let circle_col_count = Math.ceil(
					(outerbox_width - circles_margin_left)  // Don't `- circles_margin_right`. It messes up the calculation
					/ circle_distance
				);
				let circle_row_count = Math.ceil(
					countries_sorted_by_date_of_1st_confirmed_case.length
					/ circle_col_count
				);

				let svg_height  = margin_top
					+ slider_height
					+ circles_margin_top
					+ circle_distance * (circle_row_count - 1)
					+ circles_margin_bottom
					+ margin_bottom;

				// ---------- ---------- svg ---------- ---------- //
				let svg = d3.select("#chart")
					.attr('width', svg_width)
					.attr("height", svg_height)
					.style("background-color", "#fff");
				;

				// ---------- ---------- circles ---------- ---------- //
				let g_circles = d3.select("#circles")
					.attr("transform", `translate(${margin_left}, ${(margin_top + slider_height)})`);

				let each_g = g_circles
				.selectAll("g").data(countries_sorted_by_date_of_1st_confirmed_case).enter().append("g")
					.attr("id", (d, i) => `country_${i}`)
					.attr(
						"transform",
						(d, i) => {
							let quotient = Math.floor(i/circle_col_count);
							let remainder = i % circle_col_count;

							let left = circles_margin_left + circle_distance * remainder;
							let top = circles_margin_top + circle_distance * quotient;
							return `translate(${left}, ${top})`;
						}
					)

				function format_unix_timestamp(unix_timestamp){
					return new Date(unix_timestamp)
						.toLocaleDateString(
							"en-US",
							{ year: 'numeric', month: 'short', day: 'numeric' },
						);
				}
				function jhu_short_year_format(date){
					// return date.toLocaleDateString(
					// 	"en-US",
					// 	// { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' },
					// 	{ year: 'short', month: 'numeric', day: 'numeric' },
					// );
					return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear() % 100}`
				}
				function jhu_long_year_format(date){
					return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`
				}
				let initial_date = last_date;
				// initial_date = new Date("2020-03-24");

				function sqrt_and_scale_count_as_radius(count){
					return Math.sqrt(count) / 2 || 0;  // There's sometimes garbage numbers like -1
					// TODO: 2
				}
				function sqrt_and_scale_population_as_radius(count){
					return Math.sqrt(count) / 10 || 0;  // There's sometimes garbage numbers like -1
					// TODO: 10
				}

				function _get_count(country_to_date_to_count, country, date){
					let date_to_count = country_to_date_to_count[country] || {};
					return date_to_count[jhu_short_year_format(date)]
						|| date_to_count[jhu_long_year_format(date)]
						|| 0;
				}
				function get_count_confirmed(country, date){
					return _get_count(country_to_date_to_count_confirmed, country, date);
				}
				function get_count_recoveries(country, date){
					return _get_count(country_to_date_to_count_recoveries, country, date);
				}
				function get_count_deaths(country, date){
					return _get_count(country_to_date_to_count_deaths, country, date);
				}

				function _is_count_unknown(country_to_date_to_count, country, date){
					let date_to_count = country_to_date_to_count[country];
					if (typeof date_to_count === "undefined"){
						return true;
					}
					let count = date_to_count[jhu_short_year_format(date)]
						|| date_to_count[jhu_long_year_format(date)];
					return (typeof count === "undefined");
				}
				function is_count_confirmed_unknown(country, date){
					return _is_count_unknown(country_to_date_to_count_confirmed, country, date);
				}
				function is_count_recoveries_unknown(country, date){
					return _is_count_unknown(country_to_date_to_count_recoveries, country, date);
				}
				function is_count_deaths_unknown(country, date){
					return _is_count_unknown(country_to_date_to_count_deaths, country, date);
				}

				// populations
				each_g
				.append("circle")
					.classed("population", true)
					.attr(
						"r",
						(country, i) => {
							return sqrt_and_scale_population_as_radius(
								country_to_population[country] || 0
							);
						}
					)

				// confirmed cases
				each_g
				.append("circle")
					.classed("confirmed", true)
					.attr(
						"r",
						(country, i) => {
							return sqrt_and_scale_count_as_radius(
								get_count_confirmed(country, initial_date)
							);
						}
					)
				;

				// recoveries + deaths
				each_g
				.append("circle")
					.classed("recoveries", true)
					.attr(
						"r",
						(country, i) => {
							return sqrt_and_scale_count_as_radius(
								get_count_recoveries(country, initial_date)
								+ get_count_deaths(country, initial_date)
							);
						}
					)
				;

				// deaths
				each_g
				.append("circle")
					.classed("deaths", true)
					.attr(
						"r",
						(country, i) => {
							return sqrt_and_scale_count_as_radius(
								get_count_deaths(country, initial_date)
							);
						}
					)
				;

				// country name text
				let MAX_COUNTRY_NAME_LENGTH = 7;
				function ellipticize(country, i){
					if (country.length > MAX_COUNTRY_NAME_LENGTH) {
						return `${country.slice(0, MAX_COUNTRY_NAME_LENGTH)}...`;
					}
					else {
						return country;
					}
				}

				each_g
				.append("text")
					.classed("country_name", true)
					.attr("x", 5)
					// .text((country, i) => country)
					.text(ellipticize)
				;

				// invisible dummy areas + tooltip
				var tooltip_div = d3.select("body").append("div")
					.classed("tooltip", true)
					.style("opacity", 0);

				// each_g
				// .append("circle")
				// 	.attr("opacity", 0)
				// 	.attr("r", circle_distance / 2)
				let g_dummies = d3.select("#dummies")
					.attr("transform", `translate(${margin_left}, ${(margin_top + slider_height)})`);

				g_dummies
				.selectAll("rect").data(countries_sorted_by_date_of_1st_confirmed_case).enter().append("rect")
					.attr(
						"transform",
						(d, i) => {
							let quotient = Math.floor(i/circle_col_count);
							let remainder = i % circle_col_count;

							let left = circles_margin_left + circle_distance * remainder;
							let top = circles_margin_top + circle_distance * quotient;
							return `translate(${left}, ${top})`;
						}
					)
					.attr("opacity", 0)
					.attr("x", -circle_distance / 2)
					.attr("y", -circle_distance / 2)
					.attr("width", circle_distance)
					.attr("height", circle_distance)
				.on("mouseover", function(country, i){
					let g_country_i = d3.select(`g#country_${i}`);

					// display full country name
					g_country_i.select("text.country_name")
						.classed("selected", true)
						.text(country);

					// population circle
					g_country_i.select("circle.population")
						.classed("selected", true);

					// tooltip
					tooltip_div
						.transition().duration(500)
						.style("opacity", .8);
					tooltip_div
						.html(
							country
							+ "<br/><span class='tooltip_label'>Date of first confirmed case: </span>"
								+ format_unix_timestamp(
									country_to_date_of_1st_confirmed_case[country]
								)
							+ "<br/><span class='tooltip_label'>Confirmed cases: </span>"
								+ (
									is_count_confirmed_unknown(country, initial_date)
									? "N/A"
									: get_count_confirmed(country, initial_date)
								)
							+ " (<span class='tooltip_label'>Active: </span>"
								+ (
									(
										is_count_confirmed_unknown(country, initial_date)
										|| is_count_recoveries_unknown(country, initial_date)
										|| is_count_deaths_unknown(country, initial_date)
									)
									? "N/A"
									: (
										get_count_confirmed(country, initial_date)
										- get_count_recoveries(country, initial_date)
										- get_count_deaths(country, initial_date)
									)
								)
							+ ")"
							+ "<br/><span class='tooltip_label'>Recoveries: </span> "
								+ (
									is_count_recoveries_unknown(country, initial_date)
									? "N/A"
									: get_count_recoveries(country, initial_date)
								)
							+ "<br/><span class='tooltip_label'>Deaths: </span>"
								+ (
									is_count_deaths_unknown(country, initial_date)
									? "N/A"
									: get_count_deaths(country, initial_date)
								)
						)
						.style("left", (d3.event.pageX) + "px")
						.style("top", (d3.event.pageY) + "px");
				})
				.on("mouseout", function(country, i){
					let g_country_i = d3.select(`g#country_${i}`);

					// ellipticize country name
					g_country_i.select("text.country_name")
						.classed("selected", false)
						.text(ellipticize(country));

					// population circle
					g_country_i.select("circle.population")
						.classed("selected", false);

					// tooltip
					tooltip_div
						.classed("selected", false)
						.transition().duration(500)
						.style("opacity", 0);;
				})

				// ---------- ---------- slider ---------- ---------- //
				let g_slider = d3.select("#slider")
					.attr("transform", `translate(${margin_left}, ${margin_top})`);

				//Slider Properties
				let minValue = first_date.getTime();
				let maxValue = last_date.getTime();
				let initialValue = maxValue;
				let stepSize = 86400000;  // 24 h/d * 60 m/h * 60 s/m * 1000 ms/s  // Add stepSize
				let color = "#51cbcb"; // green #51cb3f
				let emptyColor = "#ececec"; // gray
				let thumbColor = "white";
				let lineWidth = 6;
				let thumbSize = 6;

				let value;
				let valueNormalized = (initialValue-minValue)/(maxValue-minValue); // value normalized between 0-1
				let valueScaled = valueNormalized * slider_width;
				let stepSizeScaled = stepSize / (maxValue-minValue) * slider_width;  // Add stepSize

				// Display the date
				document.getElementById("date_value").innerHTML = format_unix_timestamp(initialValue);

				//Line to represent the current value
				let valueLine = g_slider.append("line")
					.attr("x1", 0)
					.attr("x2", slider_width * valueNormalized)
					.attr("y1", margin_top)
					.attr("y2", margin_top)
					.style("stroke", color)
					.style("stroke-linecap", "round")
					.style("stroke-width", lineWidth);

				//Line to show the remaining value
				let emptyLine = g_slider.append("line")
					.attr("x1", slider_width * valueNormalized)
					.attr("x2", slider_width)
					.attr("y1", margin_top)
					.attr("y2", margin_top)
					.style("stroke", emptyColor)
					.style("stroke-linecap", "round")
					.style("stroke-width", lineWidth);

				// "ticks"
				let num_of_days = Math.ceil((maxValue - minValue)/stepSize) + 1;
				let ticks = g_slider
				.selectAll("circle").data(new Array(num_of_days)).enter().append("circle")
					.attr("fill", "white")
					.attr("r", 1.5)
					.attr("cx", (d, i) => i * stepSizeScaled)
					.attr("cy", margin_top);

				//Draggable circle to represent the current value
				let valueCircle = g_slider.append("circle")
					.attr("cx", slider_width * valueNormalized)
					.attr("cy", margin_top)
					.attr("r", thumbSize)
					.style("stroke", "black")
					.style("stroke-width", 1)
					.style("fill", thumbColor)
					.call(d3.drag().on("drag", dragEnded));

				function dragEnded() {
					valueScaled = d3.event.x;

					// Add stepSize
					let floored = Math.floor(valueScaled / stepSizeScaled) * stepSizeScaled;
					let remainder = valueScaled % stepSizeScaled;
					if(remainder){
						if(remainder < stepSizeScaled / 2){
							valueScaled = floored;
						}
						else{
							valueScaled = floored + stepSizeScaled;
						}
					}

					if (valueScaled < 0)
						valueScaled = 0;
					else if (valueScaled > slider_width)
						valueScaled = slider_width;

					valueNormalized = valueScaled / slider_width;
					value = valueNormalized*(maxValue-minValue)+minValue;
					valueCircle.attr("cx", valueScaled);
					valueLine.attr("x2", slider_width * valueNormalized);
					emptyLine.attr("x1", slider_width * valueNormalized);

					d3.event.sourceEvent.stopPropagation();

					// Display the date
					document.getElementById("date_value").innerHTML = format_unix_timestamp(value);

					// confirmed cases
					each_g
					.selectAll("circle.confirmed")
						.attr(
							"r",
							(country, i) => {
								return sqrt_and_scale_count_as_radius(
									get_count_confirmed(country, new Date(value))
								);
							}
						)
					;
					// recoveries + deaths
					each_g
					.selectAll("circle.recoveries")
						.attr(
							"r",
							(country, i) => {
								return sqrt_and_scale_count_as_radius(
									get_count_recoveries(country, new Date(value))
									+ get_count_deaths(country, new Date(value))
								);
							}
						)
					;
					// deaths
					each_g
					.selectAll("circle.deaths")
						.attr(
							"r",
							(country, i) => {
								return sqrt_and_scale_count_as_radius(
									get_count_deaths(country, new Date(value))
								);
							}
						)
					;

					// invisible dummy areas + tooltip
					g_dummies
					.selectAll("rect")
					.on("mouseover", function(country, i){
						let g_country_i = d3.select(`g#country_${i}`);

						// display full country name
						g_country_i.select("text.country_name")
							.classed("selected", true)
							.text(country);

						// population circle
						g_country_i.select("circle.population")
							.classed("selected", true);

						// tooltip
						tooltip_div
							.transition().duration(500)
							.style("opacity", .8);
						tooltip_div
							.html(
								country
								+ "<br/><span class='tooltip_label'>Date of first confirmed case: </span>"
									+ format_unix_timestamp(
										country_to_date_of_1st_confirmed_case[country]
									)
								+ "<br/><span class='tooltip_label'>Confirmed cases: </span>"
									+ (
										is_count_confirmed_unknown(country, new Date(value))
										? "N/A"
										: get_count_confirmed(country, new Date(value))
									)
								+ " (<span class='tooltip_label'>Active: </span>"
									+ (
										(
											is_count_confirmed_unknown(country, new Date(value))
											|| is_count_recoveries_unknown(country, new Date(value))
											|| is_count_deaths_unknown(country, new Date(value))
										)
										? "N/A"
										: (
											get_count_confirmed(country, new Date(value))
											- get_count_recoveries(country, new Date(value))
											- get_count_deaths(country, new Date(value))
										)
									)
								+ ")"
								+ "<br/><span class='tooltip_label'>Recoveries: </span> "
									+ (
										is_count_recoveries_unknown(country, new Date(value))
										? "N/A"
										: get_count_recoveries(country, new Date(value))
									)
								+ "<br/><span class='tooltip_label'>Deaths: </span>"
									+ (
										is_count_deaths_unknown(country, new Date(value))
										? "N/A"
										: get_count_deaths(country, new Date(value))
									)
							)
							.style("left", (d3.event.pageX) + "px")
							.style("top", (d3.event.pageY) + "px");
					})
				}
			}
		);
	</script>
</html>